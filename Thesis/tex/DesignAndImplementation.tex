\documentclass{../local}
\begin{document}
\section{REXOS overall architecture}

\section{Scheduling \& Planning - TODO - }
The normal scheduling algorithm used in the simulator is taken from \emph{L. van Moergestel’s paper ‘Multiagent-based agile manufacturing: from user requirements to product.} \textbf{- INSERT QUOTE HERE - } and the batch scheduling algorithm is described below. Scheduling is done by the product agent, which represents a product.
The product consists of steps, which are specific tasks defined by a set of parameters. Think of screwing, glu-ing or welding. All the equiplets in a grid can perform a certain set of these tasks. The ability to perform such a task is called a capability.  Each equiplet only has a limited set of these capabilities.

\subsection{Planning - TODO}
In the simulation a grid consisting of equiplets is defined. Each equiplet has its own set of capabilities. Now consider a product with an n amount of product steps($\phi$):\\

$< \phi_1, \phi_2, ... \phi_n >$\\

Once the product (agent) spawns, it will match all possible equiplets to complete all of its steps. Meaning that it compiles a collection containing equiplets combined with the product steps they can perform. That seems like a lot, but the equiplets do not have a large set of capabilities. The resulting collection is:\\

$< E1(\phi_1, \phi_3), E2(\phi_2, \phi_3, \phi_1), E3(\phi_1) >$\\

Once this collection has been compiled,  the product(agent) starts negotiating with the equiplets. It informs with each of the equiplets to evaluate whether or not the step can be performed with the given parameters at the given equiplet.  Once all equiplets have been queried and matched, the actual planning begins.
The first step in the planning consist of reducing the transition time between product steps. First a production matrix is constructed. The rows represent the equiplets while the columns represent the product steps.

\begin{table}[htbp]
\centering
\normalsize
\begin{tabular}{|l|l|l|l|l|l|}
\hline
	& $\phi$1 & $\phi$2 & $\phi$3 & $\phi$4 & $\phi$5 \\
\hline
Equiplet 1 & 1.0 & 0.0 & 1.0 & 1.0 & 1.0 \\
\hline
Equiplet 2 & 0.0 & 1.0 & 0.0 & 0.0 & 0.0 \\
\hline
Equiplet 3 & 0.0 & 0.0 & 0.0 & 0.0 & 1.0 \\
\hline
Equiplet 4 & 1.0 & 0.0 & 1.0 & 1.0 & 0.0 \\
\hline
\end{tabular}
\caption{Initial production matrix}
\end{table}

First off, all equiplets that are capable of performing a step have their value raised to 1.
The next step is to minimize transition. 


To prevent excess transition between equiplets during manufacturing, all equiplets with sequential steps have their value raised by the length of the sequence -1.  Resulting in the following matrix:

\begin{table}[htbp]
\centering
\normalsize
\begin{tabular}{|l|l|l|l|l|l|}
\hline
	& $\phi$1 & $\phi$2 & $\phi$3 & $\phi$4 & $\phi$5 \\
\hline
Equiplet 1 & 1.0 & 0.0 & 3.0 & 3.0 & 3.0 \\
\hline
Equiplet 2 & 0.0 & 1.0 & 0.0 & 0.0 & 0.0 \\
\hline
Equiplet 3 & 0.0 & 0.0 & 0.0 & 0.0 & 1.0 \\
\hline
Equiplet 4 & 1.0 & 0.0 & 2.0 & 2.0 & 0.0 \\
\hline
\end{tabular}
\caption{Production matrix after transition optimisation}
\end{table}

As is shown in figure (above) E1 is able to perform step 3, 4 \& 5. The corresponding values where increased by 2 ( sequence length is 3, minus 1 ).

Another easy but important optimization is load balancing. All equiplets are responsible for their own schedule which makes calculating the load at a given time feasible.
Consider a product querying a equiplet to calculate its load for scheduling its 57’th step. This step has to be carried out not at release time, but at release time + $\Delta$ ( where $\Delta$delta is the time the previous 56 steps will take, including travel time. ) meaning that the equiplet has to calculate load over that time (called a window).

Consider the following 2 schedules:

%\includegraphics[width=.98\linewidth]{}

If the equiplet would calculate load over release time + window length, it would not be a correct calculation. In above image equiplet 1 has a load of 90\% whereas equiplet 2 has a load of 20\%.
In order to favor the equiplets with least load, all numbers in the matrix are multiplied with ( 1 - (load) ).

Applying this to our current production matrix, and a imaginary constant load ( E1 - 60\%, E2 - 20\%, E3 - 40\% and E4 - 10\% ), the matrix will result in:

\begin{table}[htbp]
\centering
\normalsize
\begin{tabular}{|l|l|l|l|l|l|}
\hline
	& $\phi$1 & $\phi$2 & $\phi$3 & $\phi$4 & $\phi$5 \\
\hline
Equiplet 1 & 0.4 & 0.0 & 1.2 & 1.2 & 1.2 \\
\hline
Equiplet 2 & 0.0 & 0.8 & 0.0 & 0.0 & 0.0 \\
\hline
Equiplet 3 & 0.0 & 0.0 & 0.0 & 0.0 & 0.6 \\
\hline
Equiplet 4 & 0.4 & 0.0 & 1.2 & 1.2 & 0.0 \\
\hline
\end{tabular}
\caption{Production matrix after load balancing}
\end{table}

(steps Ø 3,Ø 4 \& Ø 5 on E1 are multiplied by ( 1 - 0.6 ) which results in 3 * 0.4  )
As seen in the figure above, E1 which has a load of 60\% is suddenly not the best option for steps 3 \& anymore. This way, a proper load balance between the equiplets is achieved.

Another important optimization is reducing the travel time between steps. Much like reducing the transition time between steps that can be executed on the same equiplet, this optimization is meant to reduce travel time within the grid. In order to do so, a distance matrix is utilized. This matrix has equiplets in both the rows as columns, and travel times between these as values ( in amount of timeslots required to travel  from 1 to another ):

\begin{table}[htbp]
\centering
\normalsize
\begin{tabular}{|l|l|l|l|l|}
\hline
	& Equiplet 1 & Equiplet 2 & Equiplet 3 & Equiplet 4  \\
\hline
Equiplet 1 & x & 3.0 & 1.0 & 2.0 \\
\hline
Equiplet 2 & 3.0 & x & 6.0 & 3.0 \\
\hline
Equiplet 3 & 1.0 & 6.0 & x & 6.0 \\
\hline
Equiplet 4 & 2.0 & 3.0 & 6.0 & x \\
\hline
\end{tabular}
\caption{Grid distance matrix}
\end{table}

Now, utilising the production matrix, the product will try and use a path of least resistance algorithm to find the most suitable path within the grid.




Ignoring all 0 values,  the following possible paths are presented:
 

Combined with the weight of the values in the production matrix, a couple of feasible paths are calculated. These parts are then scheduled sequentially. ( taking the best path first ).

\subsection{Scheduling}
 locking/atomair 
 schedule equiplet
 error handling
 
\section{Simulation}
\subsection{GUI}
\subsubsection{Requirements}
These requirements were set up using the MoSCoW method. All requirements are listed first, a more detailed description for each requirement can be found directly following the list. Each entry on the list has either an 'M', 'S', 'C' or 'W' following it for the MoSCoW method.
\begin{enumerate}
\item Simulation Interface - M
\begin{enumerate}
\item Start simulation - M
\item Stop simulation - S
\item Insert error into equiplet - M
\item Visualize grid - C
\item Read configuration files - S
\item Open simulation editor - S
\end{enumerate}
\item Simulation Editor Interface - S
\begin{enumerate}
\item Create the following virtual objects: - M
\begin{enumerate}
\item Capability
\item Equiplet
\item Product
\item Batch
\item Grid
\end{enumerate}
\item When creating the above, be able to assign previously made objects where applicable (ex. Create new capability \{ Saw \}, Create new equiplet with the capability \{ Saw \}) - M
\item Output capabilities.csv, products.csv, batches.csv, grid.json - M
\item Read above files and create objects from the parsed input - S
\end{enumerate}
\end{enumerate}

\begin{description}
\item[Simulation Interface] \hfill \\
The interface used to control the simulation. This interface will also be used to display any feedback given.

\item[Start simulation] \hfill \\
Used to start running the simulation.

\item[Stop simulation] \hfill \\
Used to stop running the simulation.

\item[Insert error into equiplet] \hfill \\
Used to put a virtual equiplet into a state of error. This can be used to simulate hardware or software failure.

\item[Visualize grid] \hfill \\
When simulating a virtual grid of equiplets, it would be more intuitive to see the grid visualized instead of manually checking a single equiplets' position within the grid. It is however, not required for the application to perform.

\item[Read configuration files] \hfill \\
When running a large number of test simulations, it would save time if the grid configuration, products and capabilities could be read from a file, rather than needing to re-define the composition every time a new simulation is started.

\item[Open simulation editor] \hfill \\
While not strictly necessary, having a button to open the configuration editor saves time and unnecessary complexity when trying to run the application.

\item[Simulation Editor Interface] \hfill \\
This interface will be used to quickly create or modify a configuration. It has the ability to create virtual objects.

\item[Create Objects] \hfill \\
The sole function of the editor interface is to create virtual objects, therefore it needs to have that feature.

\item[Assign newly made objects to one currently being created] \hfill \\
Given the following example:

\begin{enumerate}
\item Create a capability called 'Saw'
\item Create a virtual equiplet, which has the 'Saw' capability
\end{enumerate}

To create a new virtual equiplet, the interface must have a way of selecting previously made capabilities. This also counts for products, batches and the grid.

\item[Output files] \hfill \\
The editor exists to simplify the creation of configuration files, making the feature to output the configuration files a must have.

\item[Read and parse files] \hfill \\
While it is possible to create a new configuration rapidly using the interface, if one has already been made before, it would be easier to read that configuration and make an adjustment rather than re-creating it from scratch.
\end{description}

\subsubsection{Interface Concepts}
\begin{figure}[h!]
	\caption{The main simulation interface.}
	\centering
	\includegraphics[width=12cm]{../images/MainGUI-MainScreen}
	\vspace{-20pt}
\end{figure}

\begin{figure}[h!]
	\caption{A list showing all the equiplets in the simulation.}
	\centering
	\includegraphics[width=12cm]{../images/MainGUI-EquipletList}
	\vspace{-20pt}
\end{figure}

\begin{figure}[h!]
	\caption{The simulation editor interface.}
	\centering
	\includegraphics[width=12cm]{../images/EditorGUI-MainScreen}
\end{figure}

\subsubsection{Implementation}
The main simulation interface was implemented by another team, which is why this section will only cover the simulation editor interface.

Since the goal of the interface is creating virtual objects that represent the objects on the platform, it was decided to create several classes which describe these objects, rather than using the data classes already available. The existing data classes expect certain parameters which are unobtainable while editing the simulation. Due to this restriction, the following descriptive classes were implemented:

\begin{itemize}
\item EquipletDescription
\item BatchDescription
\item ProductDescription
\end{itemize}

implementation:
- new data classes
- dialogs
\end{document}
