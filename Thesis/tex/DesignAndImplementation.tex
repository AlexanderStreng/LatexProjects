\documentclass[11pt]{../local}
\begin{document}
\section{REXOS overall architecture}

\section{Scheduling \& Planning - TODO - }
The normal scheduling algorithm used in the simulator is taken from \emph{L. van Moergestel’s paper ‘Multiagent-based agile manufacturing: from user requirements to product.} \textbf{- INSERT QUOTE HERE - } and the batch scheduling algorithm is described below. Scheduling is done by the product agent, which represents a product.
The product consists of steps, which are specific tasks defined by a set of parameters. Think of screwing, glu-ing or welding. All the equiplets in a grid can perform a certain set of these tasks. The ability to perform such a task is called a capability.  Each equiplet only has a limited set of these capabilities.

\subsection{Planning - TODO}
In the simulation a grid consisting of equiplets is defined. Each equiplet has its own set of capabilities. Now consider a product with an n amount of product steps($\phi$):\\

$< \phi_1, \phi_2, ... \phi_n >$\\

Once the product (agent) spawns, it will match all possible equiplets to complete all of its steps. Meaning that it compiles a collection containing equiplets combined with the product steps they can perform. That seems like a lot, but the equiplets do not have a large set of capabilities. The resulting collection is:\\

$< E1(\phi_1, \phi_3), E2(\phi_2, \phi_3, \phi_1), E3(\phi_1) >$\\

Once this collection has been compiled,  the product(agent) starts negotiating with the equiplets. It informs with each of the equiplets to evaluate whether or not the step can be performed with the given parameters at the given equiplet.  Once all equiplets have been queried and matched, the actual planning begins.
The first step in the planning consist of reducing the transition time between product steps. First a production matrix is constructed. The rows represent the equiplets while the columns represent the product steps.

\begin{table}[htbp]
\centering
\normalsize
\begin{tabular}{|l|l|l|l|l|l|}
\hline
	& $\phi$1 & $\phi$2 & $\phi$3 & $\phi$4 & $\phi$5 \\
\hline
Equiplet 1 & 1.0 & 0.0 & 1.0 & 1.0 & 1.0 \\
\hline
Equiplet 2 & 0.0 & 1.0 & 0.0 & 0.0 & 0.0 \\
\hline
Equiplet 3 & 0.0 & 0.0 & 0.0 & 0.0 & 1.0 \\
\hline
Equiplet 4 & 1.0 & 0.0 & 1.0 & 1.0 & 0.0 \\
\hline
\end{tabular}
\caption{Initial production matrix}
\end{table}

First off, all equiplets that are capable of performing a step have their value raised to 1.
The next step is to minimize transition. 


To prevent excess transition between equiplets during manufacturing, all equiplets with sequential steps have their value raised by the length of the sequence -1.  Resulting in the following matrix:

\begin{table}[htbp]
\centering
\normalsize
\begin{tabular}{|l|l|l|l|l|l|}
\hline
	& $\phi$1 & $\phi$2 & $\phi$3 & $\phi$4 & $\phi$5 \\
\hline
Equiplet 1 & 1.0 & 0.0 & 3.0 & 3.0 & 3.0 \\
\hline
Equiplet 2 & 0.0 & 1.0 & 0.0 & 0.0 & 0.0 \\
\hline
Equiplet 3 & 0.0 & 0.0 & 0.0 & 0.0 & 1.0 \\
\hline
Equiplet 4 & 1.0 & 0.0 & 2.0 & 2.0 & 0.0 \\
\hline
\end{tabular}
\caption{Production matrix after transition optimisation}
\end{table}

As is shown in figure (above) E1 is able to perform step 3, 4 \& 5. The corresponding values where increased by 2 ( sequence length is 3, minus 1 ).

Another easy but important optimization is load balancing. All equiplets are responsible for their own schedule which makes calculating the load at a given time feasible.
Consider a product querying a equiplet to calculate its load for scheduling its 57’th step. This step has to be carried out not at release time, but at release time + $\Delta$ ( where $\Delta$delta is the time the previous 56 steps will take, including travel time. ) meaning that the equiplet has to calculate load over that time ( called a window).

Consider the following 2 schedules:

%\includegraphics[width=.98\linewidth]{}

If the equiplet would calculate load over release time + window length, it would not be a correct calculation. In above image equiplet 1 has a load of 90\% whereas equiplet 2 has a load of 20\%.
In order to favor the equiplets with least load, all numbers in the matrix are multiplied with ( 1 – (load) ).

Applying this to our current production matrix, and a imaginary constant load ( E1 – 60\%, E2 – 20\%, E3 – 40\% and E4 – 10\% ), the matrix will result in:

\begin{table}[htbp]
\centering
\normalsize
\begin{tabular}{|l|l|l|l|l|l|}
\hline
	& $\phi$1 & $\phi$2 & $\phi$3 & $\phi$4 & $\phi$5 \\
\hline
Equiplet 1 & 0.4 & 0.0 & 1.2 & 1.2 & 1.2 \\
\hline
Equiplet 2 & 0.0 & 0.8 & 0.0 & 0.0 & 0.0 \\
\hline
Equiplet 3 & 0.0 & 0.0 & 0.0 & 0.0 & 0.6 \\
\hline
Equiplet 4 & 0.4 & 0.0 & 1.2 & 1.2 & 0.0 \\
\hline
\end{tabular}
\caption{Production matrix after load balancing}
\end{table}

(steps Ø 3,Ø 4 \& Ø 5 on E1 are multiplied by ( 1 – 0.6 ) which results in 3 * 0.4  )
As seen in the figure above, E1 which has a load of 60\% is suddenly not the best option for steps 3 \& anymore. This way, a proper load balance between the equiplets is achieved.

Another important optimization is reducing the travel time between steps. Much like reducing the transition time between steps that can be executed on the same equiplet, this optimization is meant to reduce travel time within the grid. In order to do so, a distance matrix is utilized. This matrix has equiplets in both the rows as columns, and travel times between these as values ( in amount of timeslots required to travel  from 1 to another ):

\begin{table}[htbp]
\centering
\normalsize
\begin{tabular}{|l|l|l|l|l|}
\hline
	& Equiplet 1 & Equiplet 2 & Equiplet 3 & Equiplet 4  \\
\hline
Equiplet 1 & x & 3.0 & 1.0 & 2.0 \\
\hline
Equiplet 2 & 3.0 & x & 6.0 & 3.0 \\
\hline
Equiplet 3 & 1.0 & 6.0 & x & 6.0 \\
\hline
Equiplet 4 & 2.0 & 3.0 & 6.0 & x \\
\hline
\end{tabular}
\caption{Grid distance matrix}
\end{table}

Now, utilising the production matrix, the product will try and use a path of least resistance algorithm to find the most suitable path within the grid.




Ignoring all 0 values,  the following possible paths are presented:
 

Combined with the weight of the values in the production matrix, a couple of feasible paths are calculated. These parts are then scheduled sequentially. ( taking the best path first ).

\subsection{Scheduling}

After the production plan has been made, the product agent will then schedule its plan at the corresponding equiplets. 

In an agile manufacturing environment, there is a high possibility that multiple product agents will be scheduling at the same time at the same equiplet. When this happens, it is likely that the product agents will try to schedule at the same time. Resulting in concurrency errors.

To prevent these situations, the planning and scheduling operations have to be atomic actions \textbf{-reference from L. Moergestel paper-}. Once a product agent starts requesting information of the schedule of an equiplet with the intention of scheduling new product steps, the equiplet will lock its schedule and give the key to that product agent. Other product agents needing to schedule cannot request any information of the schedule of this 'locked' equiplet's schedule. Once the product agent that received the key of the equiplet's schedule is done scheduling, the product agent will unlock this schedule and other product agents will be able to schedule on this equiplet again.

Using the above mentioned planning algorithm will result in a lot of schedules used and locked by the product agent, but not all of these schedules will be chosen to produce on. Given the following situation: There are three equiplets providing capability one ( drilling ). When a product agent spawns and wants to schedule, whose product steps needs the capability drilling, it will lock all of the three equiplet's schedule. When a second product agent wants to schedule that needs the same capability, it cannot lock any of the required equiplets.

The most efficient way of resolving this issue is to let the second product agent wait until the equiplet's schedules are unlocked. The main reason for this is that the planning algorithm has the best results when all of the possible equiplets for the required product steps are used. Excluding some of the equiplets from the algorithm will eventually result in an inefficient production route for some products.

Using the above solution for the problem could cause a major software deadlock in the MAS system. A situation can occur that multiple product agents need to wait for eachother. The following figure will illustrate this:

\includegraphics{../images/Scheduledeadlock}

In the above picture two product agents are spawned at the same time and need the same equiplets. In the MAS system, the product agent will send lock requests to the equiplet agents. It is possible that the last sent message ( the message to EQ$_3$ ) will be received first. In above situation PA$_1$'s messages are received in order from EQ$_1$ to EQ$_3$ and PA$_2$'s messages from EQ$_3$ to EQ$_1$. For this example messages are processed at 1 message per tick.

After the first tick, PA$_1$ has the lock of EQ$_1$ and PA$_2$ has the lock of EQ$_3$. After the second tick a race condition appears and in this case PA$_1$ gets the lock of EQ$_2$, PA$_2$ will not get the lock of EQ$_2$ and will need to wait for it at the end, but PA$_2$ will continue since he needs EQ$_3$. Now for the next tick, there is a problem. PA$_1$ requests the lock of EQ$_3$, but is not given the lock because PA$_2$ already has the lock. For the same reason the lock of EQ$_1$ cannot be given to PA$_2$. Given the above solution we end up in a deadlock because PA$_1$ will wait for the lock of EQ$_3$ to release and PA$_2$ will wait for the release of the lock of EQ$_1$.

To solve this problem, this situation has to be detected and resolved. Detection can be done as following: When an product agent (PA$_1$) stumbles upon a locked equiplet (EQ$_3$), it will request the address of the product agent that locked EQ$_3$, resulting in the address of PA$_2$. PA$_1$ will then send a message to PA$_2$, notifying PA$_2$ that PA$_1$ is in need of the locked EQ$_3$. When PA$_2$  will detect a locked EQ$_1$ that is locked by PA$_1$, by asking EQ$_1$ the address of the locker, PA$_2$ will compare the address returned with its notification list and will detect the deadlock of two product agents that need eachother's locked equiplets.

There is also another case where the above solution can probably not detect a deadlock with three or more product agents. Given the following case with three product agents //todo case

To resolve this deadlock, the detector will start a negotiation with all of the involved product agents. A choice will have to be made who will start with producing. Based on what information can vary on the needs of the current grid setup. For example: if deadlines are a high priority, the product agent with the earliest deadline will be chosen first, or if the product with the shortest produce time are useful to let them schedule first. Further research on this topic can be done to provide an answer. The chosen equiplet will be given a queue of the remaining product agents sorted on who goes when and will be passed on until all of the 'deadlocked' product agents have finished scheduling.

schedule representation
freetimeslots
schedule equiplet
error handling
 
\section{Simulation}



\subsection{GUI}
\end{document}
