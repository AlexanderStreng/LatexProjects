\documentclass{../local}
\begin{document}

\section{Recommendations}
\subsection{Schedule Lock - TODO}
The schedule lock design described in section \ref{sec:schedulelock} ( locked scheduling ), is a proposed solution based on the dangers of multithreaded software. The design ensures that every product gets his time to plan his steps at the required equiplets. Also, when a deadlock appears it can be an oppertunity to let certain products with a high priority schedule first. However, It is possible to abandon the idea of using a lock for a schedule and use a 'first come, first served' design ( free scheduling ).

The idea of locked scheduling is based on the idea that the data of the schedules of the equiplets may not change when a product agent is starting his schedule routine up until the product agent has saved his new schedule at the corresponding equiplets. To create an optimal plan, the product agent needs the schedules of all of the equiplets that can perform the needed product steps. In big grids with multiple equiplets for a single capability, the result of the plan will only include some of the equiplets mentioned before. So some didn't had its schedule changed and could have been used by another product agent without violating the 'atomic scheduling' rule.

When not using locks for equiplet's schedules, this can be utilized. But using this kind of approach can be dangerous to the integrity of the built plan by the product agent, but can be resolved. Given the following situation with two product agents: PA$_1$ and PA$_2$, the following situation can occur. PA$_1$ has gathered all of the required data and has started calculating his optimal production path. PA$_2$ does the same, at the same time, and the result is the same as that of PA$_1$, but is done earlyer. After PA$_2$ has pushed his schedule to the equiplets earlyer, and used the equiplets that PA$_1$ was going to use too. PA$_1$'s calculated schedule has been compromised and will be detected when pushing his new schedule. This can be easily resolved by just restarting calculating the plan.

Advantage is that multiple product agents can use the same equiplets to calculate the plans and that these plans don't interfere with eachother. But this solution can be prone to error too. For example, having a product with a lot of product steps would require a relatively long schedule time, and a long batch with a very low amount of product steps. In the previously described situation, the batch products would cause the product to restart over and over again. This could result that the product can't schedule its steps because of faster interfering smaller products.

While this is a different approach than the locked scheduling solution, research is required to conclude which solution is better, or if a combination of both is feasible.

\subsection{Scheduling algorithm improvements - TODO}
The current scheduling algorithm takes different aspects of the condition and state of an equiplet into account. Choosing efficiently a suitable equiplet with these has been proven. What the algorithm doesn't take account for is transporting products between equiplets.

When a product needs transportation to another equiplet for another product step to be excecuted, it is possible that a only looking at the state of the equiplet can be misleading. An equiplet that has for example a higher load could be better to produce because its position is closer to the product's current whereabouts. Also the availability of transportation resources can be limited and therefore slowing down the production.

So the algorithm needs to be improved by taking transportation components into account. This can be done by adding new formulas to the production matrix.

\subsection{Simulation improvements}
The simulation program was made in a very limited timeframe, therefor there are some features left out which would make it work a lot better. One of said features is the ability to simulate a certain number of products rather than simulating a certain amount of time. This new ability makes it possible to run a number of new test cases for gathering performance data.

At this time, the scheduling algorthm implemented into the simulation does not match what is currently implemented in the REXOS platform. When scheduling is improved and/or implemented into REXOS, the scheduling implementation in the simulation should be updated to match this.

The graphical user interface could be extended to make it possible to modify all the parameters in the simulation, this would improve the user experience enormously. Another feature that would improve user experience is adding he possibility of outputting graphs for statistical data, rather than csv (comma-seperated value) files.

\end{document}